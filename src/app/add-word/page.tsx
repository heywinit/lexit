'use client';

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useMutation, useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import toast, { Toaster } from "react-hot-toast";
import { useRouter } from "next/navigation";
import { ChevronsLeft, LoaderPinwheel } from "lucide-react";
import { useEffect, useState } from "react";
import WordCard from "@/components/WordCard";

const notifySuccess = () => toast.success("Word added successfully!");
const notifyError = (message: string) => toast.error(`${message}`);

export default function AddWord() {
  const router = useRouter();
  const words = useQuery(api.words.getWords) || [];
  const createWord = useMutation(api.words.createWord);

  const [word, setWord] = useState("");
  const [debouncedWord, setDebouncedWord] = useState(word);
  const [AIDebouncedWord, setAIDebouncedWord] = useState(word);
  const [meaningExists, setMeaningExists] = useState(false);
  const [loading, setLoading] = useState(false);

  const [meaning, setMeaning] = useState("");

  useEffect(() => {
    setMeaning("");

    const convexSearch = setTimeout(() => {
      setDebouncedWord(word);
    }, 500)

    const aiSearch = setTimeout(() => {
      setAIDebouncedWord(word);
    }, 3000)

    return () => { clearTimeout(convexSearch), clearTimeout(aiSearch) };
  }, [word])

  useEffect(() => {
    if (!AIDebouncedWord || meaningExists) return;

    const fetchMeaning = async () => {
      try {
        setLoading(true);
        const res = await fetch('/api/generate-meaning', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ word: AIDebouncedWord }),
        })

        if (!res.ok) throw new Error("Failed to generate meaning");
        const data = await res.json();
        setMeaning(data.definition);
      } catch (error) {
        notifyError((error as Error).message);
      } finally {
        setLoading(false);
      }
    }

    fetchMeaning();
  }, [AIDebouncedWord])

  const existingWords = words.map(w => w.word.toLowerCase());
  const alreadyExists = existingWords.includes(word.toLowerCase());

  useEffect(() => {
    if (!word.trim() || !alreadyExists) {
      setMeaningExists(false);
    } else if (alreadyExists) {
      setMeaningExists(true);
    }
  }, [alreadyExists])

  const getWord = useQuery(api.words.getWordByName, debouncedWord ? { word: debouncedWord } : "skip");

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!word.trim()) return notifyError("Word cannot be empty");
    if (word.includes(' ')) return notifyError("Word cannot contain spaces");
    if (alreadyExists) return notifyError("Word already exists");

    try {
      void createWord({
        word,
        meaning: "",
        examples: []
      });
      notifySuccess();
      setWord("")
      setMeaningExists(false);
    } catch (error) {
      notifyError((error as Error).message);
    }
  }

  return (
    <main className="flex flex-col items-center justify-center text-black min-h-screen">
      <div className="mr-auto mx-6">
        <Button variant="outline" className="mb-10" onClick={() => router.push('/')}>
          <ChevronsLeft size={16} />
          Back
        </Button>
      </div>
      <div className="w-full px-6">
        <h1 className="text-3xl">What new word did you discover?</h1>
        <form className="mt-4" onSubmit={handleSubmit}>
          <Input
            type="text"
            name="word"
            placeholder="Enter new word"
            className="mt-5"
            value={word}
            onChange={(e) => { setWord(e.target.value) }}
          />
          {meaning.length > 0 && (
            <section>
              <label className="mt-5 block font-medium text-sm text-gray-700">Definition (generated by AI)</label>
              <Input
                type="text"
                name="meaning"
                className="mt-2 border-dashed border-2"
                value={meaning}
                onChange={(e) => setMeaning(e.target.value)}
              />
            </section>
          )}
          {loading && (
            <div className="flex items-center mt-5">
              <LoaderPinwheel className="animate-spin mr-2" />
              <p>Generating definition...</p>
            </div>
          )}
          <Button type="submit" className="mt-5 w-full">Add Word</Button>
        </form>
      </div>
      {alreadyExists && getWord && getWord?.word?.length > 0 && (
        <div className="flex flex-col mt-5 justify-center items-center">
          <WordCard
            word={getWord?.word || ""}
            meaning={getWord?.meaning || ""}
            examples={getWord?.examples || []}
          />
        </div>
      )}
      <Toaster position="bottom-right" />
    </main>
  )
}
